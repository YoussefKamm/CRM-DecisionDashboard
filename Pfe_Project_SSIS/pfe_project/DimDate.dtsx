<?xml version="1.0"?>
<DTS:Executable xmlns:DTS="www.microsoft.com/SqlServer/Dts"
  DTS:refId="Package"
  DTS:CreationDate="4/18/2024 11:13:22 AM"
  DTS:CreationName="Microsoft.Package"
  DTS:CreatorComputerName="DESKTOP-U58L4FM"
  DTS:CreatorName="DESKTOP-U58L4FM\ASUS"
  DTS:DTSID="{ED3D46D2-7B8D-4FB0-8D2E-D1B2D4034C6D}"
  DTS:ExecutableType="Microsoft.Package"
  DTS:LastModifiedProductVersion="16.0.5397.1"
  DTS:LocaleID="1033"
  DTS:ObjectName="Package1"
  DTS:PackageType="5"
  DTS:VersionBuild="1"
  DTS:VersionGUID="{8E644EAB-8720-46D7-A1FB-AF386AF51782}">
  <DTS:Property
    DTS:Name="PackageFormatVersion">8</DTS:Property>
  <DTS:Variables />
  <DTS:Executables>
    <DTS:Executable
      DTS:refId="Package\Execute SQL Task"
      DTS:CreationName="Microsoft.ExecuteSQLTask"
      DTS:Description="Execute SQL Task"
      DTS:DTSID="{2BDB751A-C928-4CCC-B06D-86E386236AB9}"
      DTS:ExecutableType="Microsoft.ExecuteSQLTask"
      DTS:LocaleID="-1"
      DTS:ObjectName="Execute SQL Task"
      DTS:TaskContact="Execute SQL Task; Microsoft Corporation; SQL Server 2022; © 2022 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1"
      DTS:ThreadHint="0">
      <DTS:Variables />
      <DTS:ObjectData>
        <SQLTask:SqlTaskData
          SQLTask:Connection="{6A6FEE0D-9800-4F35-AE71-C147942857DE}"
          SQLTask:SqlStatementSource="&#x9;--Make sure you set the Start and End Date below on row 58 and 59&#xA; --Create the tables&#xA; BEGIN TRY&#xA; DROP TABLE [DimDate];&#xA; END TRY&#xA; BEGIN CATCH&#xA; --DO NOTHING&#xA; END CATCH&#xA;&#xA; &#xA;&#xA;CREATE TABLE [dbo].[DimDate]&#xA; (&#xA; --[DateSK] [int] IDENTITY(1,1) NOT NULL--Use this line if you just want an autoincrementing counter AND COMMENT BELOW LINE&#xA; [DateSK]                      INT          NOT NULL, --TO MAKE THE DateSK THE YYYYMMDD FORMAT USE THIS LINE AND COMMENT ABOVE LINE.&#xA; [FullDate]                    DATETIME     NOT NULL,&#xA; [Day]                         TINYINT      NOT NULL,&#xA; [DaySuffix]                   VARCHAR (4)  NOT NULL,&#xA; [DayOfWeek]                   VARCHAR (9)  NOT NULL,&#xA; [DayOfWeekNumber]             INT          NOT NULL,&#xA; [DayOfWeekInMonth]            TINYINT      NOT NULL,&#xA; [DayOfYearNumber]             INT          NOT NULL,&#xA; [RelativeDays]                INT          NOT NULL,&#xA; [WeekOfYearNumber]            TINYINT      NOT NULL,&#xA; [WeekOfMonthNumber]           TINYINT      NOT NULL,&#xA; [RelativeWeeks]               INT          NOT NULL,&#xA; [CalendarMonthNumber]         TINYINT      NOT NULL,&#xA; [CalendarMonthName]           VARCHAR (9)  NOT NULL,&#xA; [RelativeMonths]              INT          NOT NULL,&#xA; [CalendarQuarterNumber]       TINYINT      NOT NULL,&#xA; [CalendarQuarterName]         VARCHAR (6)  NOT NULL,&#xA; [RelativeQuarters]            INT          NOT NULL,&#xA; [CalendarYearNumber]          INT          NOT NULL,&#xA; [RelativeYears]               INT          NOT NULL,&#xA; [StandardDate]                VARCHAR (10) NULL,&#xA; [WeekDayFlag]                 BIT          NOT NULL,&#xA; [HolidayFlag]                 BIT          NOT NULL,&#xA; [OpenFlag]                    BIT          NOT NULL,&#xA; [FirstDayOfCalendarMonthFlag] BIT          NOT NULL,&#xA; [LastDayOfCalendarMonthFlag]  BIT          NOT NULL,&#xA; [HolidayText]                 VARCHAR (50) NULL CONSTRAINT [PK_DimDate] PRIMARY KEY CLUSTERED ([DateSK] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90) ON [PRIMARY]&#xA; ) ON [PRIMARY];&#xA;&#xA; &#xA; GO&#xA; --Populate Date dimension&#xA; TRUNCATE TABLE DimDate;&#xA;&#xA; &#xA;&#xA;--IF YOU ARE USING THE YYYYMMDD format for the primary key then you need to comment out this line.&#xA; --DBCC CHECKIDENT (DimDate, RESEED, 60000) --In case you need to add earlier dates later.&#xA; DECLARE @tmpDOW TABLE (&#xA; DOW  INT,&#xA; Cntr INT); --Table for counting DOW occurance in a month&#xA;&#xA; &#xA;&#xA;INSERT  INTO @tmpDOW (DOW, Cntr)&#xA; VALUES              (1, 0); --Used in the loop below&#xA;&#xA; &#xA;&#xA;INSERT  INTO @tmpDOW (DOW, Cntr)&#xA; VALUES              (2, 0);&#xA;&#xA; &#xA;&#xA;INSERT  INTO @tmpDOW (DOW, Cntr)&#xA; VALUES              (3, 0);&#xA;&#xA; &#xA;&#xA;INSERT  INTO @tmpDOW (DOW, Cntr)&#xA; VALUES              (4, 0);&#xA;&#xA; &#xA;&#xA;INSERT  INTO @tmpDOW (DOW, Cntr)&#xA; VALUES              (5, 0);&#xA;&#xA; &#xA;&#xA;INSERT  INTO @tmpDOW (DOW, Cntr)&#xA; VALUES              (6, 0);&#xA;&#xA; &#xA;&#xA;INSERT  INTO @tmpDOW (DOW, Cntr)&#xA; VALUES              (7, 0);&#xA;&#xA; &#xA;&#xA;DECLARE @StartDate AS DATETIME,&#xA; @EndDate AS DATETIME,&#xA; @Date AS DATETIME,&#xA; @WDofMonth AS INT,&#xA; @CurrentMonth AS INT,&#xA; @CurrentDate AS DATE = getdate();&#xA;&#xA; &#xA;&#xA;SELECT @StartDate = '1/1/2000', -- Set The start and end date&#xA; @EndDate = '1/01/2020', --Non inclusive. Stops on the day before this.&#xA; @CurrentMonth = 1; --Counter used in loop below.&#xA;&#xA; &#xA;&#xA;SELECT @Date = @StartDate;&#xA;&#xA; &#xA;&#xA;WHILE @Date &lt; @EndDate&#xA; BEGIN&#xA; IF DATEPART(MONTH, @Date) &lt;&gt; @CurrentMonth&#xA; BEGIN&#xA; SELECT @CurrentMonth = DATEPART(MONTH, @Date);&#xA; UPDATE  @tmpDOW&#xA; SET Cntr = 0;&#xA; END&#xA; UPDATE  @tmpDOW&#xA; SET Cntr = Cntr + 1&#xA; WHERE   DOW = DATEPART(DW, @DATE);&#xA; SELECT @WDofMonth = Cntr&#xA; FROM   @tmpDOW&#xA; WHERE  DOW = DATEPART(DW, @DATE);&#xA; INSERT INTO DimDate ([DateSK], [FullDate], [Day], [DaySuffix], [DayOfWeek], [DayOfWeekNumber], [DayOfWeekInMonth], [DayOfYearNumber], [RelativeDays], [WeekOfYearNumber], [WeekOfMonthNumber], [RelativeWeeks], [CalendarMonthNumber], [CalendarMonthName], [RelativeMonths], [CalendarQuarterNumber], [CalendarQuarterName], [RelativeQuarters], [CalendarYearNumber], [RelativeYears], [StandardDate], [WeekDayFlag], [HolidayFlag], [OpenFlag], [FirstDayOfCalendarMonthFlag], [LastDayOfCalendarMonthFlag], HolidayText) --TO MAKE THE DateSK THE YYYYMMDD FORMAT UNCOMMENT THIS LINE… Comment for autoincrementing.&#xA; SELECT CONVERT (VARCHAR, @Date, 112) AS [DateSK], --TO MAKE THE DateSK THE YYYYMMDD FORMAT UNCOMMENT THIS LINE COMMENT FOR AUTOINCREMENT&#xA; @Date AS [FullDate],&#xA; DATEPART(DAY, @DATE) AS [Day],&#xA; CASE&#xA; WHEN DATEPART(DAY, @DATE) IN (11, 12, 13) THEN CAST (DATEPART(DAY, @DATE) AS VARCHAR) + 'th'&#xA; WHEN RIGHT(DATEPART(DAY, @DATE), 1) = 1 THEN CAST (DATEPART(DAY, @DATE) AS VARCHAR) + 'st'&#xA; WHEN RIGHT(DATEPART(DAY, @DATE), 1) = 2 THEN CAST (DATEPART(DAY, @DATE) AS VARCHAR) + 'nd'&#xA; WHEN RIGHT(DATEPART(DAY, @DATE), 1) = 3 THEN CAST (DATEPART(DAY, @DATE) AS VARCHAR) + 'rd' ELSE CAST (DATEPART(DAY, @DATE) AS VARCHAR) + 'th'&#xA; END AS [DaySuffix],&#xA; CASE DATEPART(DW, @DATE)&#xA; WHEN 1 THEN 'Sunday'&#xA; WHEN 2 THEN 'Monday'&#xA; WHEN 3 THEN 'Tuesday'&#xA; WHEN 4 THEN 'Wednesday'&#xA; WHEN 5 THEN 'Thursday'&#xA; WHEN 6 THEN 'Friday'&#xA; WHEN 7 THEN 'Saturday'&#xA; END AS [DayOfWeek],&#xA; DATEPART(DW, @DATE) AS [DayOfWeekNumber],&#xA; @WDofMonth AS [DOWInMonth], --Occurance of this day in this month. If Third Monday then 3 and DOW would be Monday.&#xA; DATEPART(dy, @Date) AS [DayOfYearNumber], --Day of the year. 0 — 365/366&#xA; DATEDIFF(dd, @CurrentDate, @Date) AS [RelativeDays],&#xA; DATEPART(ww, @Date) AS [WeekOfYearNumber], --0-52/53&#xA; DATEPART(ww, @Date) + 1 - DATEPART(ww, CAST (DATEPART(mm, @Date) AS VARCHAR) + '/1/' + CAST (DATEPART(yy, @Date) AS VARCHAR)) AS [WeekOfMonthNumber],&#xA; DATEDIFF(ww, @CurrentDate, @Date) AS [RelativeWeeks],&#xA; DATEPART(MONTH, @DATE) AS [CalendarMonthNumber], --To be converted with leading zero later.&#xA; DATENAME(MONTH, @DATE) AS [CalendarMonthName],&#xA; DATEDIFF(MONTH, @CurrentDate, @Date) AS [RelativeMonths],&#xA; DATEPART(qq, @DATE) AS [CalendarQuarterNumber], --Calendar quarter&#xA; CASE DATEPART(qq, @DATE)&#xA; WHEN 1 THEN 'First'&#xA; WHEN 2 THEN 'Second'&#xA; WHEN 3 THEN 'Third'&#xA; WHEN 4 THEN 'Fourth'&#xA; END AS [CalendarQuarterName],&#xA; DATEDIFF(qq, @CurrentDate, @Date) AS [RelativeQuarters],&#xA; DATEPART(YEAR, @Date) AS [CalendarYearNumber],&#xA; DATEDIFF(YEAR, @CurrentDate, @Date) AS [RelativeYears],&#xA; RIGHT('0' + CONVERT (VARCHAR (2), MONTH(@Date)), 2) + '/' + RIGHT('0' + CONVERT (VARCHAR (2), DAY(@Date)), 2) + '/' + CONVERT (VARCHAR (4), YEAR(@Date)),&#xA; CASE DATEPART(DW, @DATE)&#xA; WHEN 1 THEN 0&#xA; WHEN 2 THEN 1&#xA; WHEN 3 THEN 1&#xA; WHEN 4 THEN 1&#xA; WHEN 5 THEN 1&#xA; WHEN 6 THEN 1&#xA; WHEN 7 THEN 0&#xA; END AS [WeekDayFlag],&#xA; 0 AS HolidayFlag,&#xA; CASE DATEPART(DW, @DATE)&#xA; WHEN 1 THEN 0&#xA; WHEN 2 THEN 1&#xA; WHEN 3 THEN 1&#xA; WHEN 4 THEN 1&#xA; WHEN 5 THEN 1&#xA; WHEN 6 THEN 1&#xA; WHEN 7 THEN 1&#xA; END AS OpenFlag,&#xA; CASE DATEPART(dd, @Date)&#xA; WHEN 1 THEN 1 ELSE 0&#xA; END AS [FirstDayOfCalendarMonthFlag],&#xA; CASE&#xA; WHEN DateAdd(day, -1, DateAdd(month, DateDiff(month, 0, @Date) + 1, 0)) = @Date THEN 1 ELSE 0&#xA; END AS [LastDayOfCalendarMonthFlag],&#xA; NULL AS HolidayText;&#xA; SELECT @Date = DATEADD(dd, 1, @Date);&#xA; END&#xA;&#xA; &#xA;&#xA;-- Add HOLIDAYS ————————————————————————————————————--&#xA;-- New Years Day ———————————————————————————————&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'New Year”s Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; WHERE   [CalendarMonthNumber] = 1&#xA; AND [DAY] = 1;&#xA;&#xA; &#xA;&#xA;--Set OpenFlag = 0 if New Year's Day is on weekend&#xA; UPDATE  dbo.DimDate&#xA; SET OpenFlag = 0&#xA; WHERE   DateSK IN (SELECT CASE&#xA; WHEN DayOfWeek = 'Sunday' THEN DATESK + 1&#xA; END&#xA; FROM   DimDate&#xA; WHERE  CalendarMonthNumber = 1&#xA; AND [DAY] = 1);&#xA;&#xA; &#xA;&#xA;-- Martin Luther King Day —————————————————————————————&#xA;--Third Monday in January starting in 1983&#xA; UPDATE  DimDate&#xA; SET HolidayText = 'Martin Luther King Jr. Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; WHERE   [CalendarMonthNumber] = 1 --January&#xA; AND [Dayofweek] = 'Monday'&#xA; AND CalendarYearNumber &gt;= 1983 --When holiday was official&#xA; AND [DayOfWeekInMonth] = 3; --Third X day of current month.&#xA;&#xA; &#xA; GO&#xA; --President's Day —————————————————————————————&#xA; --Third Monday in February.&#xA; UPDATE  DimDate&#xA; SET HolidayText = 'President”s Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; WHERE   [CalendarMonthNumber] = 2 --February&#xA; AND [Dayofweek] = 'Monday'&#xA; AND [DayOfWeekInMonth] = 3; --Third occurance of a monday in this month.&#xA;&#xA; &#xA; GO&#xA; --Memorial Day —————————————————————————————-&#xA; --Last Monday in May&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Memorial Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; FROM    DimDate&#xA; WHERE   DateSK IN (SELECT   MAX([DateSK])&#xA; FROM     dbo.DimDate&#xA; WHERE    [CalendarMonthName] = 'May'&#xA; AND [DayOfWeek] = 'Monday'&#xA; GROUP BY CalendarYearNumber, [CalendarMonthNumber]);&#xA;&#xA; &#xA;&#xA;--4th of July ———————————————————————————————&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Independance Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; WHERE   [CalendarMonthNumber] = 7&#xA; AND [DAY] = 4;&#xA;&#xA; &#xA;&#xA;--Set OpenFlag = 0 if July 4th is on weekend&#xA; UPDATE  dbo.DimDate&#xA; SET OpenFlag = 0&#xA; WHERE   DateSK IN (SELECT CASE&#xA; WHEN DayOfWeek = 'Sunday' THEN DATESK + 1&#xA; END&#xA; FROM   DimDate&#xA; WHERE  CalendarMonthNumber = 7&#xA; AND [DAY] = 4);&#xA;&#xA; &#xA;&#xA;--Labor Day ——————————————————————————————-&#xA; --First Monday in September&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Labor Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; FROM    DimDate&#xA; WHERE   DateSK IN (SELECT   MIN([DateSK])&#xA; FROM     dbo.DimDate&#xA; WHERE    [CalendarMonthName] = 'September'&#xA; AND [DayOfWeek] = 'Monday'&#xA; GROUP BY CalendarYearNumber, [CalendarMonthNumber]);&#xA;&#xA; &#xA;&#xA;--Columbus Day——————————————————————————————&#xA;--2nd Monday in October&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Columbus Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; FROM    DimDate&#xA; WHERE   DateSK IN (SELECT   MIN(DateSK)&#xA; FROM     dbo.DimDate&#xA; WHERE    [CalendarMonthName] = 'October'&#xA; AND [DayOfWeek] = 'Monday'&#xA; AND [DayOfWeekInMonth] = 2&#xA; GROUP BY CalendarYearNumber, [CalendarMonthNumber]);&#xA;&#xA; &#xA;&#xA;--Veteran's Day ————————————————————————————————————--&#xA; UPDATE  DimDate&#xA; SET HolidayText = 'Veteran”s Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; WHERE   DateSK IN (SELECT CASE&#xA; WHEN DayOfWeek = 'Saturday' THEN DateSK - 1&#xA; WHEN DayOfWeek = 'Sunday' THEN DateSK + 1 ELSE DateSK&#xA; END AS VeteransDateSK&#xA; FROM   DimDate&#xA; WHERE  [CalendarMonthNumber] = 11&#xA; AND [DAY] = 11);&#xA;&#xA; &#xA; GO&#xA; --THANKSGIVING ————————————————————————————————————--&#xA; --Fourth THURSDAY in November.&#xA; UPDATE  DimDate&#xA; SET HolidayText = 'Thanksgiving Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; WHERE   [CalendarMonthNumber] = 11&#xA; AND [DAYOFWEEK] = 'Thursday'&#xA; AND [DayOfWeekInMonth] = 4;&#xA;&#xA; &#xA; GO&#xA; --CHRISTMAS ——————————————————————————————-&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Christmas Day',&#xA; HolidayFlag = 1,&#xA; OpenFlag    = 0&#xA; WHERE   [CalendarMonthNumber] = 12&#xA; AND [DAY] = 25;&#xA;&#xA; &#xA;&#xA;--Set OpenFlag = 0 if Christmas on weekend&#xA; UPDATE  dbo.DimDate&#xA; SET OpenFlag = 0&#xA; WHERE   DateSK IN (SELECT CASE&#xA; WHEN DayOfWeek = 'Sunday' THEN DATESK + 1&#xA; WHEN Dayofweek = 'Saturday' THEN DateSK - 1&#xA; END&#xA; FROM   DimDate&#xA; WHERE  CalendarMonthNumber = 12&#xA; AND DAY = 25);&#xA;&#xA; &#xA;&#xA;-- Valentine's Day&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Valentine''s Day'&#xA; WHERE   CalendarMonthNumber = 2&#xA; AND [DAY] = 14;&#xA;&#xA; &#xA;&#xA;-- Saint Patrick's Day&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Saint Patrick''s Day'&#xA; WHERE   [CalendarMonthNumber] = 3&#xA; AND [DAY] = 17;&#xA;&#xA; &#xA; GO&#xA; --Mother's Day —————————————————————————————&#xA; --Second Sunday of May&#xA; UPDATE  DimDate&#xA; SET HolidayText = 'Mother''s Day' --select * from DimDate&#xA; WHERE   [CalendarMonthNumber] = 5 --May&#xA; AND [Dayofweek] = 'Sunday'&#xA; AND [DayOfWeekInMonth] = 2; --Second occurance of a monday in this month.&#xA;&#xA; &#xA; GO&#xA; --Father's Day —————————————————————————————&#xA; --Third Sunday of June&#xA; UPDATE  DimDate&#xA; SET HolidayText = 'Father''s Day' --select * from DimDate&#xA; WHERE   [CalendarMonthNumber] = 6 --June&#xA; AND [Dayofweek] = 'Sunday'&#xA; AND [DayOfWeekInMonth] = 3; --Third occurance of a monday in this month.&#xA;&#xA; &#xA; GO&#xA; --Halloween 10/31 ———————————————————————————-&#xA; UPDATE  dbo.DimDate&#xA; SET HolidayText = 'Halloween'&#xA; WHERE   [CalendarMonthNumber] = 10&#xA; AND [DAY] = 31;&#xA;&#xA; &#xA;&#xA;-- Election Day————————————————————————————--&#xA;-- The first Tuesday after the first Monday in November.&#xA; BEGIN TRY&#xA; DROP TABLE #tmpHoliday;&#xA; END TRY&#xA; BEGIN CATCH&#xA; --do nothing&#xA; END CATCH&#xA;&#xA; &#xA;&#xA;CREATE TABLE #tmpHoliday&#xA; (&#xA; ID     INT      IDENTITY (1, 1),&#xA; DateID INT     ,&#xA; Week   TINYINT ,&#xA; YEAR   CHAR (4),&#xA; DAY    CHAR (2)&#xA; );&#xA;&#xA; &#xA;&#xA;INSERT INTO #tmpHoliday (DateID, [YEAR], [DAY])&#xA; SELECT   [DateSK],&#xA; CalendarYearNumber,&#xA; [DAY]&#xA; FROM     dbo.DimDate&#xA; WHERE    [CalendarMonthNumber] = 11&#xA; AND [Dayofweek] = 'Monday'&#xA; ORDER BY CalendarYearNumber, [DAY];&#xA;&#xA; &#xA;&#xA;DECLARE @CNTR AS INT,&#xA; @POS AS INT,&#xA; @STARTYEAR AS INT,&#xA; @ENDYEAR AS INT,&#xA; @CURRENTYEAR AS INT,&#xA; @MINDAY AS INT;&#xA;&#xA; &#xA;&#xA;SELECT @CURRENTYEAR = MIN([YEAR]),&#xA; @STARTYEAR = MIN([YEAR]),&#xA; @ENDYEAR = MAX([YEAR])&#xA; FROM   #tmpHoliday;&#xA;&#xA; &#xA;&#xA;WHILE @CURRENTYEAR &lt;= @ENDYEAR&#xA; BEGIN&#xA; SELECT @CNTR = COUNT([YEAR])&#xA; FROM   #tmpHoliday&#xA; WHERE  [YEAR] = @CURRENTYEAR;&#xA; SET @POS = 1;&#xA; WHILE @POS &lt;= @CNTR&#xA; BEGIN&#xA; SELECT @MINDAY = MIN(DAY)&#xA; FROM   #tmpHoliday&#xA; WHERE  [YEAR] = @CURRENTYEAR&#xA; AND [WEEK] IS NULL;&#xA; UPDATE  #tmpHoliday&#xA; SET [WEEK] = @POS&#xA; WHERE   [YEAR] = @CURRENTYEAR&#xA; AND [DAY] = @MINDAY;&#xA; SELECT @POS = @POS + 1;&#xA; END&#xA; SELECT @CURRENTYEAR = @CURRENTYEAR + 1;&#xA; END&#xA;&#xA; &#xA;&#xA;UPDATE  DT&#xA; SET HolidayText = 'Election Day'&#xA; FROM    dbo.DimDate AS DT&#xA; INNER JOIN&#xA; #tmpHoliday AS HL&#xA; ON (HL.DateID + 1) = DT.DateSK&#xA; WHERE   [WEEK] = 1;&#xA;&#xA; &#xA;&#xA;DROP TABLE #tmpHoliday;&#xA;&#xA; &#xA; GO&#xA; PRINT CONVERT (VARCHAR, GETDATE(), 113); --USED FOR CHECKING RUN TIME.&#xA;&#xA; &#xA;&#xA;--DimDate indexes———————————————————————————————&#xA; CREATE UNIQUE NONCLUSTERED INDEX [IDX_DimDate_Date]&#xA; ON [dbo].[DimDate]([FullDate] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_Day]&#xA; ON [dbo].[DimDate]([Day] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_DayOfWeek]&#xA; ON [dbo].[DimDate]([DayOfWeek] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_DOWInMonth]&#xA; ON [dbo].[DimDate]([DayOfWeekInMonth] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_DayOfYear]&#xA; ON [dbo].[DimDate]([DayOfYearNumber] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_WeekOfYear]&#xA; ON [dbo].[DimDate]([WeekOfYearNumber] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_WeekOfMonth]&#xA; ON [dbo].[DimDate]([WeekOfMonthNumber] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_Month]&#xA; ON [dbo].[DimDate]([CalendarMonthNumber] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_MonthName]&#xA; ON [dbo].[DimDate]([CalendarMonthName] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_Quarter]&#xA; ON [dbo].[DimDate]([CalendarQuarterNumber] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_QuarterName]&#xA; ON [dbo].[DimDate]([CalendarQuarterName] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_DimDate_Year]&#xA; ON [dbo].[DimDate]([CalendarYearNumber] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;CREATE NONCLUSTERED INDEX [IDX_dim_Time_HolidayText]&#xA; ON [dbo].[DimDate]([HolidayText] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)&#xA; ON [PRIMARY];&#xA;&#xA; &#xA;&#xA;PRINT CONVERT (VARCHAR, getdate(), 113); --USED FOR CHECKING RUN TIME&#xA;&#xA;&#xA;" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask" />
      </DTS:ObjectData>
    </DTS:Executable>
  </DTS:Executables>
  <DTS:DesignTimeProperties><![CDATA[<?xml version="1.0"?>
<!--This CDATA section contains the layout information of the package. The section includes information such as (x,y) coordinates, width, and height.-->
<!--If you manually edit this section and make a mistake, you can delete it. -->
<!--The package will still be able to load normally but the previous layout information will be lost and the designer will automatically re-arrange the elements on the design surface.-->
<Objects
  Version="8">
  <!--Each node below will contain properties that do not affect runtime behavior.-->
  <Package
    design-time-name="Package">
    <LayoutInfo>
      <GraphLayout
        Capacity="4" xmlns="clr-namespace:Microsoft.SqlServer.IntegrationServices.Designer.Model.Serialization;assembly=Microsoft.SqlServer.IntegrationServices.Graph">
        <NodeLayout
          Size="163,42"
          Id="Package\Execute SQL Task"
          TopLeft="224,86" />
      </GraphLayout>
    </LayoutInfo>
  </Package>
</Objects>]]></DTS:DesignTimeProperties>
</DTS:Executable>